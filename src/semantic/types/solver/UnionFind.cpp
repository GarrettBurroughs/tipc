#include "UnionFind.h"
#include "Copier.h"

#include "loguru.hpp"
#include <string>
#include <list>
#include <algorithm>

namespace { // Anonymous namespace for local helpers
bool verbose = false;
}

UnionFind::UnionFind(std::vector<std::shared_ptr<TipType>> seed) {
    for(auto &term : seed) {
        smart_insert(term);
    }
}

std::ostream& operator<<(std::ostream& os, const UnionFind& obj) {
    return obj.print(os);
}

std::ostream &UnionFind::print(std::ostream &out) const {
    std::set<std::string> edgeSet;
    for(auto edge : edges) {
        std::stringstream edgeStr;
        edgeStr << "  " << *edge.first << " => " << *edge.second;
        edgeSet.insert(edgeStr.str());
    }
  out << "UnionFind edges {\n"; 
  for(auto es : edgeSet) {
    out << es << "\n";
  }
  out << "}"; 
  return out; 
}

std::unique_ptr<UnionFind> UnionFind::copy() {
    std::vector<std::shared_ptr<TipType>> emptySeed;
    auto ufCopy = std::make_unique<UnionFind>(emptySeed);

    // Insert the vertices and edges in the copy
    for(auto const &edge : edges) {
        auto src = Copier::copy(edge.first);
        auto dest = Copier::copy(edge.second);
        smart_insert(src);
        smart_insert(dest);
        ufCopy->edges.insert(std::pair<std::shared_ptr<TipType>, std::shared_ptr<TipType>>(src, dest));
    }
    return std::move(ufCopy);
}



void UnionFind::add(std::vector<std::shared_ptr<TipType>> seed) {
    for(auto &term : seed) {
        smart_insert(term);
    }
}

/*
 * TBD: Add path compression instead of iterative parent lookup.
 */
std::shared_ptr<TipType> UnionFind::find(std::shared_ptr<TipType> t) {
    LOG_S(3) << "UnionFind looking for representive of " << *t;

    // Effectively a noop if the term is already in the map.
    smart_insert(t);

    auto parent = t;
    while(*get_parent(parent) != *parent) {
        parent = get_parent(parent);
    }

    LOG_S(3) << "UnionFind found representative " << *parent;

    return parent;
}

void UnionFind::quick_union(std::shared_ptr<TipType> t1, std::shared_ptr<TipType> t2) {
    smart_insert(t1);
    smart_insert(t2);

    auto t1_root = find(t1);
    auto t2_root = find(t2);

    // semantics-based insert
    for(auto const &edge : edges) {
        if(*t1_root == *edge.first) {
            edges.erase(edge.first);
            edges.insert(std::pair<std::shared_ptr<TipType>, std::shared_ptr<TipType>>(t1_root, t2_root));
            break;
        }
    }
}

bool UnionFind::connected(std::shared_ptr<TipType> t1, std::shared_ptr<TipType> t2) {
    return *find(t1) == *find(t2);
} // LCOV_EXCL_LINE

/*! \fn get_parent
 *
 * Unification ensures that the forest that includes all relevant type nodes.
 * A tree within the forest is traversed by directed edges to the parent.
 * During closure of terms, new type nodes may be generated by substitution.
 * When they are encountered they are added to the forest.
 */
std::shared_ptr<TipType> UnionFind::get_parent(std::shared_ptr<TipType> t) {
    for(auto const &edge : edges) {
        if(*t == *edge.first) {
            return edge.second;
        }
    }
    
    smart_insert(t);
    return t;
}

/**
 * Inserts should be based on the dereferenced value.
 */
void UnionFind::smart_insert(std::shared_ptr<TipType> t) {
    if(t == nullptr) {
        throw std::invalid_argument("Refusing to insert a nullptr into the map.");
    }

    for(auto const &edge : edges) {
        if(*t == *edge.first) {
            LOG_S(3) << "UnionFind found " << *edge.first << " in graph";
            return;
        }
    }

    LOG_S(3) << "UnionFind adding " << *t << " to graph";
    edges.insert(std::pair<std::shared_ptr<TipType>, std::shared_ptr<TipType>>(t, t));
}

std::map<std::shared_ptr<TipType>, std::shared_ptr<TipType>> UnionFind::getEdges() {
  return edges;
}

